{"version":3,"sources":["../../src/engine/engine.ts"],"sourcesContent":["import type {\n  Mission,\n  ModuleStatus,\n  ProcessingModule,\n  ProcessingRecipe,\n  ProductType,\n  RecipeInputs,\n  RecipeOutputs,\n  SimulationConfig,\n  SimulationResults,\n  WasteMaterial,\n} from '@acme/db/types'\n\n// Core simulation types\nexport interface SimulationState {\n  timestep: number\n  day: number\n  inventory: Record<string, number> // materialId -> kg\n  products: Record<string, { units: number; totalMassKg: number }>\n  metrics: {\n    energyKwh: number\n    crewHours: number\n    waterLiters: number\n    recoveredKg: number\n    wasteProcessedKg: number\n  }\n  moduleStates: Record<\n    string,\n    {\n      status: ModuleStatus\n      currentLoad: number\n      maintenanceHours: number\n    }\n  >\n}\n\nexport interface SimulationStep {\n  stepIndex: number\n  timestamp: Date\n  snapshot: SimulationState\n  events: Array<{\n    type: 'waste_collection' | 'processing' | 'product_creation' | 'maintenance'\n    description: string\n    materialsInvolved: string[]\n    energyUsedKwh?: number\n    crewTimeMinutes?: number\n  }>\n}\n\nexport interface ProcessExecution {\n  recipeId: string\n  moduleId: string\n  inputMaterials: Record<string, number> // materialId -> kg\n  outputProducts: Array<{\n    productType: ProductType\n    units: number\n    massKg: number\n  }>\n  energyKwh: number\n  crewMinutes: number\n  processingTimeMinutes: number\n}\n\nexport interface OptimizerConfig {\n  mode: 'greedy' | 'genetic' | 'milp'\n  constraints?: {\n    maxDailyEnergyKwh?: number\n    maxCrewHoursPerDay?: number\n    maxWaterLitersPerDay?: number\n  }\n  objectives: {\n    maximizeRecovery: number // weight 0-1\n    minimizeEnergy: number // weight 0-1\n    minimizeCrew: number // weight 0-1\n    maximizeUtility: number // weight 0-1\n  }\n  geneticParams?: {\n    population: number\n    generations: number\n    mutationRate: number\n    crossoverRate: number\n    seed?: number\n  }\n}\n\nexport class MarsWasteSimulator {\n  private mission: Mission\n  private materials: Map<string, WasteMaterial>\n  private modules: Map<string, ProcessingModule>\n  private recipes: Map<string, ProcessingRecipe>\n  private random: () => number\n\n  constructor(\n    mission: Mission,\n    materials: WasteMaterial[],\n    modules: ProcessingModule[],\n    recipes: ProcessingRecipe[],\n    seed?: number,\n  ) {\n    this.mission = mission\n    this.materials = new Map(materials.map((m) => [m.id, m]))\n    this.modules = new Map(modules.map((m) => [m.id, m]))\n    this.recipes = new Map(recipes.map((r) => [r.id, r]))\n\n    // Simple seeded PRNG for deterministic results\n    if (seed !== undefined) {\n      let s = seed\n      this.random = () => {\n        s = (Math.imul(s, 1664525) + 1013904223) | 0\n        return (s >>> 0) / 0x100000000\n      }\n    } else {\n      this.random = Math.random\n    }\n  }\n\n  simulate(config: SimulationConfig): SimulationResults {\n    const state = this.initializeState(config)\n    const steps: SimulationStep[] = []\n    const timeline: SimulationResults['timeline'] = []\n\n    const totalDays = config.mission_duration_days || this.mission.mission_duration_days || 365\n    const hoursPerStep = 24 // Daily simulation steps\n\n    for (let day = 0; day < totalDays; day++) {\n      state.day = day\n\n      // Generate new waste for this day\n      this.generateDailyWaste(state, config)\n\n      // Run optimizer to determine what to process today\n      const dailyPlan = this.optimizeDaily(state, config)\n\n      // Execute the daily plan\n      const dayEvents = this.executeDailyPlan(state, dailyPlan, config)\n\n      // Update module maintenance\n      this.updateModuleMaintenance(state, config)\n\n      // Record step if significant changes or every 7 days\n      if (dayEvents.length > 0 || day % 7 === 0) {\n        const step: SimulationStep = {\n          events: dayEvents,\n          snapshot: JSON.parse(JSON.stringify(state)),\n          stepIndex: day,\n          timestamp: new Date(Date.now() + day * 24 * 60 * 60 * 1000),\n        }\n        steps.push(step)\n      }\n\n      // Record timeline events\n      if (dayEvents.length > 0) {\n        timeline.push({\n          day,\n          events: dayEvents,\n        })\n      }\n    }\n\n    return this.generateResults(state, steps, timeline, config)\n  }\n\n  private initializeState(config: SimulationConfig): SimulationState {\n    const inventory: Record<string, number> = {}\n\n    // Initialize with available materials\n    for (const [materialId, rate] of Object.entries(config.waste_generation_rates || {})) {\n      inventory[materialId] = 0 // Will be generated daily\n    }\n\n    const moduleStates: Record<string, any> = {}\n    for (const moduleId of config.available_modules || []) {\n      moduleStates[moduleId] = {\n        currentLoad: 0,\n        maintenanceHours: 0,\n        status: 'active' as ModuleStatus,\n      }\n    }\n\n    return {\n      day: 0,\n      inventory,\n      metrics: {\n        crewHours: 0,\n        energyKwh: 0,\n        recoveredKg: 0,\n        wasteProcessedKg: 0,\n        waterLiters: 0,\n      },\n      moduleStates,\n      products: {},\n      timestep: 0,\n    }\n  }\n\n  private generateDailyWaste(state: SimulationState, config: SimulationConfig): void {\n    for (const [wasteType, rate] of Object.entries(config.waste_generation_rates || {})) {\n      // Find materials of this waste type\n      const typeMaterials = Array.from(this.materials.values()).filter((m) => m.category === wasteType)\n\n      if (typeMaterials.length > 0) {\n        // Distribute waste among materials of this type\n        const totalRate = rate * (config.crew_size || this.mission.crew_size || 6)\n        typeMaterials.forEach((material) => {\n          const materialRate = totalRate / typeMaterials.length\n          state.inventory[material.id] = (state.inventory[material.id] || 0) + materialRate\n        })\n      }\n    }\n  }\n\n  private optimizeDaily(state: SimulationState, config: SimulationConfig): ProcessExecution[] {\n    const executions: ProcessExecution[] = []\n    const constraints = config.optimization_goals || {\n      maximize_utility: 0.3,\n      minimize_crew_time: 0.2,\n      minimize_energy: 0.2,\n      minimize_waste: 0.3,\n    }\n\n    // Greedy optimization: sort recipes by efficiency score\n    const availableRecipes = Array.from(this.recipes.values())\n      .filter((recipe) => this.canExecuteRecipe(recipe, state))\n      .map((recipe) => ({\n        recipe,\n        score: this.calculateRecipeScore(recipe, constraints),\n      }))\n      .sort((a, b) => b.score - a.score)\n\n    const dailyEnergyLimit = config.energy_constraints?.max_daily_kwh || 100\n    const dailyCrewLimit = (config.crew_size || 6) * 8 // 8 hours per crew member\n\n    let usedEnergy = 0\n    let usedCrew = 0\n\n    for (const { recipe } of availableRecipes) {\n      // Try to execute this recipe as much as possible\n      while (this.canExecuteRecipe(recipe, state) && usedEnergy < dailyEnergyLimit && usedCrew < dailyCrewLimit) {\n        const execution = this.planRecipeExecution(recipe, state, config)\n        if (!execution) break\n\n        // Check if we can afford this execution\n        if (\n          usedEnergy + execution.energyKwh > dailyEnergyLimit ||\n          usedCrew + execution.crewMinutes / 60 > dailyCrewLimit\n        ) {\n          break\n        }\n\n        executions.push(execution)\n        usedEnergy += execution.energyKwh\n        usedCrew += execution.crewMinutes / 60\n\n        // Temporarily deduct materials to prevent over-allocation\n        for (const [materialId, amount] of Object.entries(execution.inputMaterials)) {\n          state.inventory[materialId] -= amount\n        }\n      }\n    }\n\n    // Restore inventory for actual execution\n    for (const execution of executions) {\n      for (const [materialId, amount] of Object.entries(execution.inputMaterials)) {\n        state.inventory[materialId] += amount\n      }\n    }\n\n    return executions\n  }\n\n  private calculateRecipeScore(recipe: ProcessingRecipe, objectives: any): number {\n    const inputs = recipe.inputs as RecipeInputs\n    const outputs = recipe.outputs as RecipeOutputs\n\n    const totalInputKg = Object.values(inputs).reduce((sum, input) => sum + input.quantity_kg, 0)\n    const totalOutputKg = Object.values(outputs).reduce((sum, output) => sum + output.quantity_kg, 0)\n\n    const massEfficiency = totalOutputKg / Math.max(totalInputKg, 0.001)\n    const energyEfficiency = totalOutputKg / Math.max(Number(recipe.energy_required_kwh), 0.001)\n    const crewEfficiency = totalOutputKg / Math.max(recipe.crew_time_minutes || 1, 1)\n    const yieldScore = recipe.yield_percentage || 0.8\n    const qualityScore = recipe.quality_score || 1.0\n\n    return (\n      (massEfficiency * objectives.minimize_waste +\n        energyEfficiency * objectives.minimize_energy +\n        crewEfficiency * objectives.minimize_crew_time +\n        yieldScore * qualityScore * objectives.maximize_utility) /\n      4\n    )\n  }\n\n  private canExecuteRecipe(recipe: ProcessingRecipe, state: SimulationState): boolean {\n    const inputs = recipe.inputs as RecipeInputs\n\n    for (const [materialId, requirement] of Object.entries(inputs)) {\n      const available = state.inventory[materialId] || 0\n      if (available < requirement.quantity_kg) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  private planRecipeExecution(\n    recipe: ProcessingRecipe,\n    state: SimulationState,\n    config: SimulationConfig,\n  ): ProcessExecution | null {\n    const inputs = recipe.inputs as RecipeInputs\n    const outputs = recipe.outputs as RecipeOutputs\n\n    // Find available module\n    const availableModuleId = config.available_modules?.find((moduleId) => {\n      const module = this.modules.get(moduleId)\n      const moduleState = state.moduleStates[moduleId]\n      return module && moduleState?.status === 'active'\n    })\n\n    if (!availableModuleId) return null\n\n    const inputMaterials: Record<string, number> = {}\n    let limitingFactor = 1.0\n\n    // Calculate how much we can actually process based on available materials\n    for (const [materialId, requirement] of Object.entries(inputs)) {\n      const available = state.inventory[materialId] || 0\n      const needed = requirement.quantity_kg\n      if (available < needed) {\n        limitingFactor = Math.min(limitingFactor, available / needed)\n      }\n    }\n\n    if (limitingFactor <= 0) return null\n\n    // Scale inputs by limiting factor\n    for (const [materialId, requirement] of Object.entries(inputs)) {\n      inputMaterials[materialId] = requirement.quantity_kg * limitingFactor\n    }\n\n    // Calculate outputs\n    const outputProducts = Object.entries(outputs).map(([productType, output]) => ({\n      massKg: output.quantity_kg * limitingFactor * (recipe.yield_percentage || 0.8),\n      productType: productType as ProductType,\n      units: Math.floor(output.quantity_kg * limitingFactor * (recipe.yield_percentage || 0.8)),\n    }))\n\n    return {\n      crewMinutes: (recipe.crew_time_minutes || 0) * limitingFactor,\n      energyKwh: Number(recipe.energy_required_kwh) * limitingFactor,\n      inputMaterials,\n      moduleId: availableModuleId,\n      outputProducts,\n      processingTimeMinutes: recipe.processing_time_minutes * limitingFactor,\n      recipeId: recipe.id,\n    }\n  }\n\n  private executeDailyPlan(state: SimulationState, executions: ProcessExecution[], config: SimulationConfig): any[] {\n    const events: any[] = []\n\n    for (const execution of executions) {\n      // Consume input materials\n      for (const [materialId, amount] of Object.entries(execution.inputMaterials)) {\n        state.inventory[materialId] -= amount\n        state.metrics.wasteProcessedKg += amount\n      }\n\n      // Produce outputs\n      for (const output of execution.outputProducts) {\n        const productKey = output.productType\n        if (!state.products[productKey]) {\n          state.products[productKey] = { totalMassKg: 0, units: 0 }\n        }\n        state.products[productKey].units += output.units\n        state.products[productKey].totalMassKg += output.massKg\n        state.metrics.recoveredKg += output.massKg\n      }\n\n      // Update metrics\n      state.metrics.energyKwh += execution.energyKwh\n      state.metrics.crewHours += execution.crewMinutes / 60\n\n      // Create event\n      events.push({\n        crewTimeMinutes: execution.crewMinutes,\n        description: `Processed ${Object.entries(execution.inputMaterials)\n          .map(([id, kg]) => `${kg.toFixed(1)}kg ${this.materials.get(id)?.name || id}`)\n          .join(', ')} â†’ ${execution.outputProducts.map((p) => `${p.units} ${p.productType}`).join(', ')}`,\n        energyUsedKwh: execution.energyKwh,\n        materialsInvolved: Object.keys(execution.inputMaterials),\n        type: 'processing' as const,\n      })\n    }\n\n    return events\n  }\n\n  private updateModuleMaintenance(state: SimulationState, config: SimulationConfig): void {\n    // Simple maintenance model - modules need maintenance periodically\n    for (const moduleId of Object.keys(state.moduleStates)) {\n      const module = this.modules.get(moduleId)\n      if (module) {\n        const maintenanceHours = Number(module.maintenance_hours_per_day) || 0\n        state.metrics.crewHours += maintenanceHours\n      }\n    }\n  }\n\n  private generateResults(\n    finalState: SimulationState,\n    steps: SimulationStep[],\n    timeline: SimulationResults['timeline'],\n    config: SimulationConfig,\n  ): SimulationResults {\n    const totalWasteGenerated = Object.values(config.waste_generation_rates || {}).reduce(\n      (sum, rate) => sum + rate * (config.mission_duration_days || 365) * (config.crew_size || 6),\n      0,\n    )\n\n    const wasteReductionPercentage =\n      totalWasteGenerated > 0 ? (finalState.metrics.wasteProcessedKg / totalWasteGenerated) * 100 : 0\n\n    const productsByType: Record<ProductType, number> = {} as any\n    for (const [productType, data] of Object.entries(finalState.products)) {\n      productsByType[productType as ProductType] = data.units\n    }\n\n    return {\n      efficiency_metrics: {\n        crew_time_per_kg_waste: finalState.metrics.crewHours / Math.max(finalState.metrics.wasteProcessedKg, 1),\n        energy_per_kg_waste: finalState.metrics.energyKwh / Math.max(finalState.metrics.wasteProcessedKg, 1),\n        waste_to_product_ratio: finalState.metrics.recoveredKg / Math.max(finalState.metrics.wasteProcessedKg, 1),\n      },\n      products_by_type: productsByType,\n      recommendations: this.generateRecommendations(finalState, config),\n      timeline,\n      total_crew_time_hours: finalState.metrics.crewHours,\n      total_energy_used_kwh: finalState.metrics.energyKwh,\n      total_products_created: Object.values(finalState.products).reduce((sum, p) => sum + p.units, 0),\n      total_waste_processed_kg: finalState.metrics.wasteProcessedKg,\n      waste_reduction_percentage: wasteReductionPercentage,\n    }\n  }\n\n  private generateRecommendations(state: SimulationState, config: SimulationConfig): string[] {\n    const recommendations: string[] = []\n    const efficiency = state.metrics.recoveredKg / Math.max(state.metrics.wasteProcessedKg, 1)\n\n    if (efficiency < 0.5) {\n      recommendations.push('Consider optimizing recipe yields or adding more efficient processing modules')\n    }\n\n    if (\n      state.metrics.energyKwh >\n      (config.energy_constraints?.max_daily_kwh || 100) * (config.mission_duration_days || 365)\n    ) {\n      recommendations.push('Energy consumption exceeds budget - consider more energy-efficient processes')\n    }\n\n    const unusedMaterials = Object.entries(state.inventory)\n      .filter(([_, amount]) => amount > 10)\n      .map(([id, _]) => this.materials.get(id)?.name || id)\n\n    if (unusedMaterials.length > 0) {\n      recommendations.push(\n        `Large amounts of unused materials: ${unusedMaterials.join(', ')} - consider developing new recipes`,\n      )\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Simulation completed successfully with good efficiency metrics')\n    }\n\n    return recommendations\n  }\n}\n\n// Utility function to create Sankey diagram data\nexport function generateSankeyData(\n  result: SimulationResults,\n  materials: WasteMaterial[],\n  recipes: ProcessingRecipe[],\n): {\n  nodes: Array<{ id: string; name: string; category: string }>\n  links: Array<{ source: string; target: string; value: number }>\n} {\n  const nodes: any[] = []\n  const links: any[] = []\n\n  // Add material nodes\n  materials.forEach((material) => {\n    nodes.push({\n      category: 'material',\n      id: `material_${material.id}`,\n      name: material.name,\n    })\n  })\n\n  // Add process nodes\n  recipes.forEach((recipe) => {\n    nodes.push({\n      category: 'process',\n      id: `process_${recipe.id}`,\n      name: recipe.name,\n    })\n  })\n\n  // Add product nodes\n  Object.keys(result.products_by_type).forEach((productType) => {\n    nodes.push({\n      category: 'product',\n      id: `product_${productType}`,\n      name: productType.replace('_', ' '),\n    })\n  })\n\n  // This is simplified - in practice, you'd track actual material flows\n  // through the simulation to build accurate links\n\n  return { links, nodes }\n}\n\nexport default MarsWasteSimulator\n"],"names":["MarsWasteSimulator","generateSankeyData","simulate","config","state","initializeState","steps","timeline","totalDays","mission_duration_days","mission","hoursPerStep","day","generateDailyWaste","dailyPlan","optimizeDaily","dayEvents","executeDailyPlan","updateModuleMaintenance","length","step","events","snapshot","JSON","parse","stringify","stepIndex","timestamp","Date","now","push","generateResults","inventory","materialId","rate","Object","entries","waste_generation_rates","moduleStates","moduleId","available_modules","currentLoad","maintenanceHours","status","metrics","crewHours","energyKwh","recoveredKg","wasteProcessedKg","waterLiters","products","timestep","wasteType","typeMaterials","Array","from","materials","values","filter","m","category","totalRate","crew_size","forEach","material","materialRate","id","executions","constraints","optimization_goals","maximize_utility","minimize_crew_time","minimize_energy","minimize_waste","availableRecipes","recipes","recipe","canExecuteRecipe","map","score","calculateRecipeScore","sort","a","b","dailyEnergyLimit","energy_constraints","max_daily_kwh","dailyCrewLimit","usedEnergy","usedCrew","execution","planRecipeExecution","crewMinutes","amount","inputMaterials","objectives","inputs","outputs","totalInputKg","reduce","sum","input","quantity_kg","totalOutputKg","output","massEfficiency","Math","max","energyEfficiency","Number","energy_required_kwh","crewEfficiency","crew_time_minutes","yieldScore","yield_percentage","qualityScore","quality_score","requirement","available","availableModuleId","find","module","modules","get","moduleState","limitingFactor","needed","min","outputProducts","productType","massKg","units","floor","processingTimeMinutes","processing_time_minutes","recipeId","productKey","totalMassKg","crewTimeMinutes","description","kg","toFixed","name","join","p","energyUsedKwh","materialsInvolved","keys","type","maintenance_hours_per_day","finalState","totalWasteGenerated","wasteReductionPercentage","productsByType","data","efficiency_metrics","crew_time_per_kg_waste","energy_per_kg_waste","waste_to_product_ratio","products_by_type","recommendations","generateRecommendations","total_crew_time_hours","total_energy_used_kwh","total_products_created","total_waste_processed_kg","waste_reduction_percentage","efficiency","unusedMaterials","_","seed","Map","r","undefined","s","random","imul","result","nodes","links","replace"],"mappings":"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"}